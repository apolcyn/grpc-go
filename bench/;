package main

import (
	"sync"
	"sync/atomic"
	"time"

	"google.golang.org/grpc"
	testpb "google.golang.org/grpc/benchmark/grpc_testing"
	"google.golang.org/grpc/grpclog"
)

func setPayload(p *testpb.Payload, t testpb.PayloadType, size int) {
	if size < 0 {
		grpclog.Fatalf("Requested a response with invalid length %d", size)
	}
	body := make([]byte, size)
	switch t {
	case testpb.PayloadType_COMPRESSABLE:
	case testpb.PayloadType_UNCOMPRESSABLE:
		grpclog.Fatalf("PayloadType UNCOMPRESSABLE is not supported")
	default:
		grpclog.Fatalf("Unsupported payload type: %d", t)
	}
	p.Type = t
	p.Body = body
	return
}

func newPayload(t testpb.PayloadType, size int) *testpb.Payload {
	p := new(testpb.Payload)
	setPayload(p, t, size)
	return p
}

func main() {
	grpclog.Println("start")
	p := grpc.NewProtoCodec()
	var wg sync.WaitGroup
	var total int32
	wg.Add(1)
	timeChan := time.NewTimer(time.Second * 10).C
	var done bool
	go func() {
		var count int32
		for {
			select {
			case <-timeChan:
				break
			default:
			}
			s := &testpb.SimpleResponse{
				Payload: newPayload(testpb.PayloadType_COMPRESSABLE, int(0)),
			}
			b, _ := p.Marshal(s)
			count += 1
			p.Unmarshal(b, &testpb.SimpleResponse{})
		}
		grpclog.Println("done")
		atomic.AddInt32(&total, count)
		grpclog.Println("done")
		wg.Done()
	}()

	grpclog.Println("done")
	wg.Wait()

	grpclog.Println("total is %d", total)
	grpclog.Println("done")
}
